#!/usr/bin/env mksh
# $Id$
# $miros: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.35 2022/01/07 03:20:55 tg Exp $
# $miros: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.27 2022/01/06 08:23:45 tg Exp $ +t:GRUB +s:MBR
#-
# Copyright (c) 2007, 2008, 2009, 2010, 2020, 2022
#	mirabilos <m@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# Self-installing 32-bit x86 boot blocks for GNU GRUB2 on i386-pc
# Reads a list of extents (firstblock lastblock) from standard input
# and writes bootxx to standard output, which can subsequentially be
# stored as partition boot record (or floppy boot sector) on disc.

(set -o pipefail) 2>/dev/null && set -o pipefail
unset LANGUAGE
export LC_ALL=C

set -A thecode 0x31 0xC9 0x8E 0xD1 0xBC 0xFC 0x7B 0x51 0x51 0x66 0x9D 0x8E 0xC1 0xBE 0x00 0x7C 0x8E 0xD9 0xBB 0x00 0x08 0x53 0x53 0x8E 0xC3 0xBF 0x00 0xFE 0xB5 0x02 0xF3 0xA4 0x1F 0x68 0x72 0xFE 0xCB 0x30 0x41 0x42 0x39 0x20 0x4C 0x6F 0x61 0x64 0x69 0x6E 0x67 0x20 0x00 0x20 0x65 0x72 0x72 0x6F 0x72 0x0D 0x0A 0x00 0x9D 0x02 0x00 0x12 0x00 0x00 0x80 0x5E 0xFF 0xE8 0x06 0x00 0xAC 0x08 0xC0 0x75 0xF8 0xC3 0xB4 0x0E 0x36 0x8A 0x3E 0x62 0x04 0xB3 0x07 0xCD 0x10 0xC3 0xE8 0xEB 0xFF 0xB8 0x3A 0xFF 0x87 0x06 0x43 0xFE 0x3D 0x3A 0xFF 0x75 0x19 0x31 0xC0 0xCD 0x16 0xEA 0xF0 0xFF 0x00 0xF0 0xFB 0x88 0x16 0x42 0xFE 0xBE 0x25 0xFE 0x80 0xFA 0x80 0x72 0xDB 0xE8 0xC6 0xFF 0x31 0xDB 0xBE 0x61 0xFF 0x0F 0xB6 0x2E 0x3C 0xFE 0xAC 0xD4 0x20 0x31 0xC9 0x86 0xCC 0x40 0x41 0x50 0xBF 0x10 0xFE 0xB0 0x10 0xAB 0xB0 0x01 0xAB 0x89 0xD8 0xAB 0x8C 0xC8 0xAB 0xF3 0xA4 0x31 0xC0 0xAB 0xAB 0xAB 0xAB 0x5F 0x55 0x56 0xBE 0x10 0xFE 0xFF 0x16 0x43 0xFE 0xBD 0x04 0x00 0x8A 0x16 0x42 0xFE 0x60 0xF9 0xCD 0x13 0x9C 0xB0 0x2E 0xE8 0x86 0xFF 0x9D 0xFB 0x61 0x73 0x17 0x4D 0x60 0x9C 0x31 0xC0 0xCD 0x13 0x9D 0xBE 0x33 0xFE 0x74 0x80 0xB0 0x30 0x01 0xE8 0xE8 0x6D 0xFF 0x61 0xEB 0xDA 0xB4 0x02 0x00 0xE7 0x89 0x5C 0x04 0x00 0xFC 0x72 0x12 0x66 0x83 0x44 0x08 0x01 0x66 0x83 0x54 0x0C 0x00 0x4F 0x75 0xB4 0x5E 0x5D 0x4D 0x75 0x8B 0xBE 0x39 0xFE 0xE8 0x41 0xFF 0x66 0x31 0xD2 0x52 0x66 0x4A 0x8A 0x16 0x42 0xFE 0xB8 0x00 0x82 0x50 0xFA 0xCB 0x60 0x06 0xB4 0x08 0x8A 0x16 0x42 0xFE 0xF9 0xCD 0x13 0xFB 0x07 0xBE 0x33 0xFE 0x0F 0x82 0x2F 0xFF 0x80 0xE1 0x3F 0x88 0x0E 0x3F 0xFE 0x0F 0xB6 0xC6 0x40 0xA3 0x3D 0xFE 0x61 0x8B 0x0E 0x3F 0xFE 0xE3 0xD7 0x8B 0x44 0x08 0x8B 0x54 0x0A 0xF7 0xF1 0x42 0x31 0xC9 0x87 0xD1 0xF7 0x36 0x3D 0xFE 0xC0 0xE4 0x06 0x86 0xC4 0x09 0xC1 0x88 0xD6 0xB8 0x01 0x02 0xC3 0xB4 0x42 0xC3
typeset -Uui ofs_bkcnt=60
typeset -Uui ofs_geomh=61
typeset -Uui ofs_geoms=63
typeset -Uui ofs_partp=65
typeset -Uui ofs_secsz=229
typeset -Uui begptr=353
typeset -Uui8 thecode

typeset -Uui16 curptr=begptr
typeset -i wnum=0 wofs=0 wrec=0 bkend=0x1FE

function do_record {
	typeset -Ui blk=$1 cnt=$2 n
	typeset -Uui16 x=blk y

	((# blk && cnt )) || return

	print -u2 "$wrec @0x${curptr#16#}: $cnt @$blk (0x${x#16#})"

	while ((# cnt )); do
		((# ++wrec ))
		((# n = blk < 0x00000100 ? 0 :
		    blk < 0x00010000 ? 1 :
		    blk < 0x01000000 ? 2 : 3 ))
		((# x = cnt < 33 ? cnt : 32 ))
		((# y = blk ))
		print -u2 " - 0x${curptr#16#}: $((# x )) (0x${x#16#}) @ $blk" \
		    "(0x${y#16#})"
		((# thecode[curptr++] = (n++ << 5) | (x - 1) ))
		((# blk += x ))
		((# cnt -= x ))
		while ((# n-- )); do
			((# thecode[curptr++] = y & 0xFF ))
			((# y >>= 8 ))
		done
	done
}

function record_block {
	typeset -Ui blk=$1

	if ((# !blk || (wofs && blk != (wofs + wnum)) )); then
		# flush the blocks from the cache
		((# wnum )) && do_record $wofs $wnum
		wofs=0
		wnum=0
	fi
	if ((# blk )); then
		# record some new block into the cache
		((# wofs )) || ((# wofs = blk ))
		((# wnum += 1 << sscale ))
	fi
}

typeset -i partp=0 numheads=0 numsecs=0 sscale=0 bsh=9 mbrpno=0 mbrptp=0 pofs=0
set -A g_code 0 0 0

while getopts ":0:1AB:g:h:M:O:p:S:s:" ch; do
	case $ch {
	(0)	;;
	(1)	;;
	(A)	numheads=0
		numsecs=99
		;;
	(B)	if [[ $OPTARG != [1-9]*([0-9]) ]] || \
		   ((# (bsh = OPTARG) < 9 || OPTARG > 15 )); then
			print -u2 Error: invalid block size "2^'$OPTARG'"
			exit 1
		fi
		;;
	(g)	if [[ $OPTARG != [1-9]*([0-9]):[1-9]*([0-9]):[1-9]*([0-9]) ]]; then
			print -u2 Error: invalid geometry code "'$OPTARG'"
			exit 1
		fi
		saveIFS=$IFS
		IFS=:
		set -A g_code -- $OPTARG
		IFS=$saveIFS ;;
	(h)	if [[ $OPTARG != [1-9]*([0-9]) ]] || \
		   ((# (numheads = OPTARG) < 1 || OPTARG > 256 )); then
			print -u2 Warning: invalid head count "'$OPTARG'"
			numheads=0
		fi ;;
	(M)	if [[ $OPTARG != +([0-9])?(:?(0[Xx])+([0-9])) ]]; then
			print -u2 Warning: invalid partition info "'$OPTARG'"
			mbrpno=0
			mbrptp=0
		else
			saveIFS=$IFS
			IFS=:
			set -A mbr_code -- $OPTARG
			IFS=$saveIFS
			((# mbrpno = mbr_code[0] ))
			((# mbrptp = mbr_code[1] ))
			if ((# mbrpno < 1 || mbrpno > 4 )); then
				print -u2 Warning: invalid partition \
				    number "'$OPTARG'"
				mbrpno=0
			fi
			if ((# mbrptp < 1 || mbrptp > 255 )); then
				print -u2 Warning: invalid partition \
				    type "'$OPTARG'"
				mbrptp=0
			fi
		fi ;;
	(O)	if [[ $OPTARG != @(+([0-9])|0[Xx]+([0-9a-fA-F])) ]]; then
			print -u2 Warning: invalid partition offset "'$OPTARG'"
		else
			pofs=$OPTARG
		fi ;;
	(p)	if [[ $OPTARG != @(+([0-9])|0[Xx]+([0-9a-fA-F])) ]] || \
		   ((# (partp = OPTARG) < 1 || OPTARG > 255 )); then
			print -u2 Warning: invalid partition type "'$OPTARG'"
			partp=0
		fi ;;
	(S)	if [[ $OPTARG != +([0-9]) ]] || \
		   ((# (sscale = OPTARG) > 24 )); then
			print -u2 Error: invalid input scale "'$OPTARG'"
			exit 1
		fi ;;
	(s)	if [[ $OPTARG != [1-9]*([0-9]) ]] || \
		   ((# (numsecs = OPTARG) < 1 || OPTARG > 63 )); then
			print -u2 Warning: invalid sector count "'$OPTARG'"
			numsecs=0
		fi ;;
	(*)	print -u2 'Syntax:
	bxinst [-1A] [-B blocksize] [-g C:H:S] [-h heads] [-M pno(1..4)[:typ]]
	    [-O partitionofs] [-p type] [-S scale] [-s secs] <sectorlist | \\
	    dd of=image conv=notrunc
Default values: blocksize=9 heads=16 sectors=63 part.ofs=0 type=0x27 scale=0
    partno=4 if -g (create MBR partition) is given; -A = auto boot geometry'
		exit 1 ;;
	}
done
shift $((# OPTIND - 1 ))

typeset -Ui psz=0	# must be unsigned
function check_geo {
	typeset -Ui v c=$1 h=$2 s=$3
	typeset t=

	x="$c cylinders, $h heads, $s sectors per track"
	if ((# c < 1 || h < 1 || s < 1 || h > 256 || s > 63 )); then
		y='individual geometry values out of bounds'
		return 1
	fi
	if ((# h == 256 )); then
		print -u2 'Warning: more than 255 heads do not work with DOS'
	fi
	y='geometry values too large (more than 2 TiB)'
	((# ((v = h * s) / s) == h )) || return 1
	x="$x ($v sectors per cylinder)"
	((# ((psz = c * v) / v) == c )) || return 1
	x="$psz sectors in $x"
	# only display if it can be calculated within mksh
	if ((# ((v = psz << bsh) >> bsh) == psz )); then
		x="$x ($v bytes)"
	elif t=$(print -r -- "$psz * $((# 1 << bsh ))" | bc) 2>/dev/null && \
	    [[ -n $t ]]; then
		x="$x ($t bytes)"
	fi
	return 0
}

if ((# g_code[0] )); then
	# bounds check partition table values, calculate total sectors
	if check_geo "${g_code[@]}"; then
		print -ru2 -- "geometry is $x"
	else
		print -ru2 -- "Error: $y: $x"
		exit 1
	fi
fi

if ((# psz )); then
	if ((# numsecs == 0 || (numsecs != 99 && numheads == 0) )); then
		print -u2 Warning: using these values for C/H/S boot
		numheads=${g_code[1]}
		numsecs=${g_code[2]}
	fi
	((# mbrpno )) || mbrpno=4	# default partition number
fi
if ((# mbrpno )); then
	bkend=0x1BE
	((# psz )) || print -u2 Warning: no geometry given, will not \
	    create an MBR partition table entry
fi

if ((# numsecs == 99 )); then
	numheads=0
	numsecs=0
else
	if ((# !numheads )); then
		print -u2 Warning: using default value of 16 heads
		numheads=16
	fi

	if ((# !numsecs )); then
		print -u2 Warning: using default value of 63 sectors
		numsecs=63
	fi
fi

# read in the extents
while read firstblock lastblock junk; do
	while ((# firstblock <= lastblock )); do
		record_block $((# firstblock++ << sscale ))
	done
done
record_block 0	# just flush
print -u2 "using $wrec blocks, $((# curptr - begptr )) bytes" \
    "($((# bkend - curptr )) free)"

# fill the block table
if ((# curptr-- > bkend )); then
	print -u2 Error: too many blocks
	exit 1
fi
while ((# ++curptr < bkend )); do
	let RANDOM+=SECONDS
	((# thecode[curptr] = (curptr & 0xFCF) == 0x1C2 ? 0 : RANDOM & 0xFF ))
	# ensure the "active" flag is never set to 0x00 or has the high bit set
	while ((# ((curptr + 2) & 0xFCF) == 0x01C0 )); do
		((# (thecode[curptr] = RANDOM & 0x7F) )) && break
	done
done
thecode[510]=0x55
thecode[511]=0xAA

# fill in other data
((# thecode[ofs_bkcnt] = wrec ))
((# thecode[ofs_geomh] = numheads & 0xFF ))
((# thecode[ofs_geomh + 1] = numheads >> 8 ))
((# thecode[ofs_geoms] = numsecs ))
((# thecode[ofs_partp] = partp ))
print -u2 "using sectors of 2^$bsh = $((# 1 << bsh )) bytes"
((# thecode[ofs_secsz] = (1 << (bsh - 8)) ))

# creates MBR partition spanning until the end of the drive
function mkcpart {
	typeset -Ui pno=$1 ptyp=$2 pofs=$3
	typeset -Ui d c h s

	((# d = 0x1BE + ((partno - 1) * 16) ))

	((# s = (pofs % g_code[2]) + 1 ))
	((# h = (pofs / g_code[2]) ))
	((# c = h / g_code[1] ))
	((# h = h % g_code[1] ))
	# boot flag; C/H/S offset
	((# thecode[d++] = 0x80 ))
	((# thecode[d++] = h ))
	((# c = c > 1023 ? 1023 : c ))
	((# thecode[d++] = ((c & 0x0300) >> 2) | s ))
	((# thecode[d++] = c & 0xFF ))
	# partition type; C/H/S end
	((# s = g_code[2] ))
	((# h = g_code[1] - 1 ))
	((# c = g_code[0] - 1 ))
	((# thecode[d++] = ptyp ))
	((# thecode[d++] = h ))
	((# c = c > 1023 ? 1023 : c ))
	((# thecode[d++] = ((c & 0x0300) >> 2) | s ))
	((# thecode[d++] = c & 0xFF ))
	# partition offset (LBA)
	((# thecode[d++] = (pofs) & 0xFF ))
	((# thecode[d++] = (pofs >> 8) & 0xFF ))
	((# thecode[d++] = (pofs >> 16) & 0xFF ))
	((# thecode[d++] = (pofs >> 24) & 0xFF ))
	# partition size (LBA)
	((# pofs = psz - pofs ))
	((# thecode[d++] = (pofs) & 0xFF ))
	((# thecode[d++] = (pofs >> 8) & 0xFF ))
	((# thecode[d++] = (pofs >> 16) & 0xFF ))
	((# thecode[d++] = (pofs >> 24) & 0xFF ))
}

# create an MBR partition if desired
if ((# psz )); then
	mkcpart $mbrpno $((# mbrptp ? mbrptp : partp ? partp : 0x27 )) $pofs
fi

# create the output string
ostr=
curptr=0
while ((# curptr < 512 )); do
	if ((# thecode[curptr] & ~0xFF )); then
		print -ru2 Error: overlong ${thecode[curptr]} \
		    at offset $((# curptr ))
		exit 255
	fi
	ostr=$ostr\\0${thecode[curptr++]#8#}
done

# over and out
print -n "$ostr"
exit 0
